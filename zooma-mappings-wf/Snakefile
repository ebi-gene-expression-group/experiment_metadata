import re
from os import listdir


# This workflow updates all ontology mappings in condensed SDRF files, and then
# updates all experiment designs on ves-hx-76:8080


# source bash functions

# need somewhere a mapping part, to go from many accessions build the unified reports (agreggation)


# Parse config from command line

mode = config.get("mode")
working_dir = config.get("working_dir")
exp_metadata_dir = config.get("exp_metadata_dir")


def get_accessions(working_dir):
    """
    Generate the expected output file names.
    Not yet sure if for all modes, the listdir path below
    is where the accession dirs are found.
    Edit accordingly once known.
    """
    acc_regex = re.compile("E-\D+-\d+")
    acc_dirs = os.listdir(f"{working_dir}")
    ACCESSIONS = [acc for acc in acc_dirs if acc_regex.match(acc)]
    return ACCESSIONS

ACCESSIONS = get_accessions(working_dir)


# Below probably no longer needed bec of regex above
wildcard_constraints:
    accession = "E-\D+-\d+"


# Rule for running the whole pipeline
# Not yet sure if below is the desired path for the output condensed sdrf files
# Edit accordingly once the output dir is identified
rule all:
    input:
        condensed_sdrf=expand(working_dir+"/{acc}/{acc}.condensed-sdrf.tsv", acc=ACCESSIONS),





rule check_zooma:
    """
    Check that zooma returns successful http code
    """
    log:
        "{working_dir}/logs/{accession}-check_zooma.log"
    output:
        temp("{working_dir}/{accession}/check_zooma.done")
    params:
        zoomaMetadataUrl=config['zoomaMetadataUrl']
    shell:
        """
        set -e # snakemake on the cluster doesn't stop on error when --keep-going is set
        exec &> "{log}"

        httpResponse=`curl -o /dev/null -X GET -s -w %{http_code} {params.zoomaMetadataUrl}`
        if [ "$httpResponse" -e 200 ]; then
            touch {output}
        else
            echo "ERROR: Zooma not responding correctly"
            echo "{params.zoomaMetadataUrl} returned a non-success http code: $httpResponse for {wildcards.accession}"
        fi
        """

rule remove_aux_files:
    """
    Remove auxiliary files
    """
    log:
        "{working_dir}/logs/{accession}-remove_aux_files.log"
    input:
        rules.check_zooma.output,
        working_directory=working_dir
    output:
        temp("{working_dir}/{accession}/remove_aux_files.done")
    shell:
        """
        set -e # snakemake on the cluster doesn't stop on error when --keep-going is set
        exec &> "{log}"
        pushd {input.working_directory}
        rm -rf {wildcards.accession}/condense_sdrf.???
        rm -rf {wildcards.accession}/fixes.???
        rm -rf {wildcards.accession}/{wildcards.accession}-zoomifications-log.tsv
        #rm -rf $zoomaMappingReport.aux
        touch {output}
        popd
        """

rule run_condense_sdrf:
    """
    Run condense_sdrf.pl with options to map terms with Zooma (-z) and import
    the IDF from ArrayExpress load directory (-i).
    """
    conda: "envs/perl-atlas-modules.yaml"
    log:
    input:
        "{accession}-configuration.xml"
    params:
        mode=config['mode'],
        attempt_number=attempt,
        retry_without_zooma=config['retryWithoutZooma']
    output:

    shell:
        """
        set -e # snakemake on the cluster doesn't stop on error when --keep-going is set
        exec &> "{log}"

        if [[ {params.attempt_number} -lt 2 ]]; then
            # Run condense_sdrf.pl with options to map terms with Zooma (-z) and import
            # the IDF from ArrayExpress load directory (-i).
            if [ {params.mode} == "atlas" ]; then

                # Get the experiment type from the experiment config.
                expType=$(get_experiment_type_from_xml.pl {input})

                if [[ $expType == *baseline ]]; then
                    ../condense_sdrf.pl -e {wildcards.accession} -f {wildcards.accession}/{wildcards.accession}-factors.xml -z -i -o {wildcards.accession}
                else
                    ../condense_sdrf.pl -e {wildcards.accession} -z -i -o {wildcards.accession}
                fi
            elif [ "$mode" == "single_cell" ]; then
                export EXP_ID={wildcards.accession}
                {workflow.basedir}/single_cell_condensed_sdrf.sh

            elif [ "$mode" == "irap_single_lib" ]; then
                # also collect biological replicate IDs for irap_single_lib mode
                condense_sdrf.pl -e {wildcards.accession} -z -b -i -o {wildcards.accession}
            else
                echo "Mode $mode not recognised."
                exit 1
            fi
        elif [[ {params.retry_without_zooma} == "yes" ]]; then

            # if error detected, then condense SDRF without Zooma mapping

            if [ {params.mode} == "atlas" ]; then

                expType=$(get_experiment_type_from_xml.pl {input})

                if [[ $expType == *baseline ]]; then
                    ../condense_sdrf.pl -e {wildcards.accession} -f {wildcards.accession}/{wildcards.accession}-factors.xml -i -o {wildcards.accession}
                else
                    ../condense_sdrf.pl -e {wildcards.accession} -i -o {wildcards.accession}
                fi
            elif [ "$mode" == "single_cell" ]; then
                export EXP_ID={wildcards.accession}
                export SKIP_ZOOMA={params.retry_without_zooma} 
                {workflow.basedir}/single_cell_condensed_sdrf.sh

            elif [ "$mode" == "irap_single_lib" ]; then
                # also collect biological replicate IDs for irap_single_lib mode
                condense_sdrf.pl -e {wildcards.accession} -b -i -o {wildcards.accession}
            else
                echo "Mode $mode not recognised."
                exit 1
            fi
        else
            echo "Failed to condense SDRF for {wildcards.accession}"
        fi

        #if success, run next rule

        """


rule apply_fixes:
    """
    Apply automatic fixes to all imported sdrf and idf files
    """
    resources: 
        mem_mb=16000
    log:
    input:
        autofix_properties="{exp_metadata_dir}/automatic_fixes_values.txt"
        autofix_values="{exp_metadata_dir}/automatic_fixes_properties.txt"
        idf="{working_dir}/{accession}/{accession}.idf.txt"
        condensed_sdrf="{working_dir}/{accession}/{accession}.condensed-sdrf.tsv"
    output:
        temp("{accession}/apply_fixes.done")
    shell:
        """

        # source generic_routines.sh

        applyAllFixesForExperiment {wildcards.accession} && touch {output}
        
        """

rule check_zooma_mapping_report:
    log:
    input:
    output:
    shell:
        """
        """
        

rule copy_reports_to_targetDir:
    """
    Copy reports to $targetDir.
    Mail out the Zoomification reports location
    """
    log:
    input:
    output:
    shell:
        """

        # upon sucess, mail out the Zoomification reports location 
        """
        

